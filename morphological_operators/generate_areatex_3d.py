#!python3
#
# This script generates 3D area textures for morphological antialiasing.
# It is based on the 2D version from the SMAA project.
#
# Requires:
#   - Python 3.3.2: http://www.python.org/
#   - Pillow 2.1.0: https://pypi.python.org/pypi/Pillow/2.1.0#downloads
#   - numpy: pip install numpy

from PIL import Image
from multiprocessing import *
from math import *
from tempfile import *
import operator
import numpy as np

# Texture sizes
SIZE_3D = 16

# --- 3D Pattern Definitions ---
# The 3D patterns are defined as extrusions of the 2D patterns.
# We will have 3 families of patterns, one for each plane (XY, YZ, XZ).
# For now, we will focus on the XY plane.

# The 2D patterns are numbered 0-15. We can use the same numbering scheme
# and then add a flag to indicate if it's a 3D pattern.

# --- Concave/Convex Classification ---
# We need to classify the patterns as concave or convex to apply different
# blending logic as per the user request.
#
# A simple classification for the 2D ortho patterns:
# - Convex: 1, 2, 4, 8 (L-shapes)
# - Concave: 3, 12 (U-shapes)
# - Complex/Saddle: 6, 7, 9, 11, 13, 14 (Z-shapes)
# - Flat: 0, 5, 10, 15
PATTERN_CLASSIFICATION = {
    0: 'flat', 1: 'convex', 2: 'convex', 3: 'concave',
    4: 'convex', 5: 'flat', 6: 'complex', 7: 'complex',
    8: 'convex', 9: 'complex', 10: 'flat', 11: 'complex',
    12: 'concave', 13: 'complex', 14: 'complex', 15: 'flat'
}


def cpp_header(volume, name, plane):
    """Writes a 3D texture volume to a C++ header file."""
    filename = f'AreaTex_3D_{plane}.h'
    var_name = f'areaTexBytes_3D_{plane}'

    with open(f'morphological_operators/{filename}', 'w') as f:
        f.write(f"// This file is generated by generate_areatex_3d.py\n")
        f.write(f"const unsigned int {var_name}_size = {volume.size};\n")
        f.write(f"static const unsigned char {var_name}[] = {{\n")

        f.write("   ")
        count = 0
        for val in np.nditer(volume):
            f.write(f"0x{int(val):02x},")
            count += 1
            if count % 16 == 0:
                f.write("\n   ")

        f.seek(f.tell() - 1) # Remove last comma
        f.write("\n};\n")

def area3d(pattern, x, y, z, plane):
    """
    Calculates the blending value for a given 3D pattern and coordinates.
    This is a simplified version that demonstrates the concept.
    """
    classification = PATTERN_CLASSIFICATION[pattern]

    # This is a placeholder for the actual geometric calculation.
    # For now, we'll just return a value based on the classification
    # and the distance from the center.
    dist = np.sqrt((x - SIZE_3D/2)**2 + (y - SIZE_3D/2)**2 + (z - SIZE_3D/2)**2)

    if classification == 'concave':
        # Dim white pixels to grey. In our case, this means returning a value
        # that will be interpreted as a dimming factor. Let's use a value
        # from 128 to 255, where 255 is no dimming.
        return 255 - dist * 10
    elif classification == 'convex':
        # Brighten black pixels to grey. This means returning a value that
        # will be interpreted as a brightening factor. Let's use a value
        # from 0 to 127, where 0 is no brightening.
        return dist * 10
    else:
        return 0 # No change for flat or complex patterns for now.

def generate_3d_area_texture_for_plane(plane='XY'):
    """
    Generates a 3D area texture for a specific plane.
    """
    print(f"Generating 3D Area Texture for {plane} plane...")

    # The 3D texture will be a 4D numpy array (16 patterns, each with a 3D volume).
    volume = np.zeros((16, SIZE_3D, SIZE_3D, SIZE_3D), dtype=np.uint8)

    for p in range(16):
        for z in range(SIZE_3D):
            for y in range(SIZE_3D):
                for x in range(SIZE_3D):
                    # The plane argument determines how we interpret the coordinates.
                    if plane == 'XY':
                        val = area3d(p, x, y, z, plane)
                    elif plane == 'YZ':
                        val = area3d(p, z, x, y, plane)
                    elif plane == 'XZ':
                        val = area3d(p, x, z, y, plane)

                    volume[p, z, y, x] = np.clip(val, 0, 255)

    cpp_header(volume, "AreaTex3D", plane)
    print(f"Finished generating 3D Area Texture for {plane} plane.")


if __name__ == '__main__':
    # We need to install numpy first
    try:
        import numpy
    except ImportError:
        print("Numpy not found. Please install it using 'pip install numpy'")
        exit()

    generate_3d_area_texture_for_plane('XY')
    generate_3d_area_texture_for_plane('YZ')
    generate_3d_area_texture_for_plane('XZ')
